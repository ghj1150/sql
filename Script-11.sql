-- 주소록 테이블 생성
-- id varchar(100), name varchar(100)
CREATE TABLE ADDR(
	ID VARCHAR2(100),
	NAME VARCHAR2(100)
);

-- 주소록에 컬럼추가 birth date
ALTER TABLE ADDR ADD (BIRTH DATE);

SELECT * FROM ADDR2;

-- 주소록에 COMMENTS 컬럼 추가 VARCHAR(200) 기본값 'NO COMMENT'
ALTER TABLE ADDR ADD (COMMENTS VARCHAR2(200) DEFAULT 'NO COMMENT');

INSERT INTO ADDR (ID) VALUES ('id1');

-- 주소록에 COMMENTS 컬럼 삭제
ALTER TABLE ADDR DROP (COMMENTS);

-- 주소록 ID 컬럼의 크기를 10 BYTE로 변경
ALTER TABLE ADDR MODIFY ID VARCHAR(10);

-- ADDR 테이블 이름을 ADDR2로 변경
RENAME ADDR TO ADDR2;

-- ADDR2 테이블에다가 '주소록' 이라는 COMMNET 추가
COMMENT ON TABLE ADDR2 IS '주소록';

-- ADDR2의 NAME 컬럼에 '이름' 이라는 COMMNET 추가
COMMENT ON COLUMN ADDR2.NAME IS '이름';

-- 강좌 테이블 생성 (SUBJECT)
-- SUBNO 번호
-- SUBNAME 이름
-- TERM 학기 (1,2)
-- TYPE 필수 여부 CHAR(1)

CREATE TABLE SUBJECT (
	SUBNO NUMBER CONSTRAINT SUBJECT_PK PRIMARY KEY,
	SUBNAME VARCHAR(200) CONSTRAINT SUBNAME_NN NOT NULL,
	TERM CHAR(1) CONSTRAINT TERM_CK CHECK (TERM IN ('1','2')),
	TYPE CHAR(1)
);

ALTER TABLE STUDENT ADD CONSTRAINT STUDENT_PK PRIMARY KEY(STUDNO);

CREATE TABLE SUGANG(
	STUDNO CONSTRAINT SUGANG_STUDNO_FK REFERENCES STUDENT,
	SUBNO NUMBER,
	REGDATE DATE,
	RESULT NUMBER(3),
	CONSTRAINT SUGANG_SUBNO_FK FOREIGN KEY(SUBNO) REFERENCES SUBJECT(SUBNO),
	CONSTRAINT SUGANG_PK PRIMARY KEY(STUDNO, SUBNO)
);

-- 학과 테이블에 제약조건 넣기
-- PK : DEPTNO, DNAME : NN, COLLEGE <> DEPTNO FK
ALTER TABLE DEPARTMENT MODIFY (DEPTNO CONSTRAINT DEPARTMENT_PK PRIMARY KEY);
ALTER TABLE DEPARTMENT MODIFY (DNAME NOT NULL);
ALTER TABLE DEPARTMENT MODIFY (COLLEGE REFERENCES DEPARTMENT(DEPTNO));

SELECT * FROM PROFESSOR;
-- 교수 테이블에 제약조건 넣기
-- PK, 이름 NN, 아이디 UNIQUE, FK DEPTNO
ALTER TABLE PROFESSOR ADD CONSTRAINT PROFESSOR_PK PRIMARY KEY(PROFNO);
ALTER TABLE PROFESSOR MODIFY (NAME NOT NULL);
ALTER TABLE PROFESSOR ADD CONSTRAINT PROF_USERID_UK UNIQUE(USERID);
ALTER TABLE PROFESSOR ADD FOREIGN KEY(DEPTNO) REFERENCES DEPARTMENT;

SELECT * FROM STUDENT;
-- 학생
-- 이름 NN, 아이디 UNIQUE, 주민번호 UNIQUE, FK DEPTNO, FK PROFNO
ALTER TABLE STUDENT MODIFY (NAME NOT NULL);
ALTER TABLE STUDENT ADD CONSTRAINT STUD_USERID_UK UNIQUE(USERID);
ALTER TABLE STUDENT ADD CONSTRAINT STUD_IDNUM_UK UNIQUE(IDNUM);
ALTER TABLE STUDENT MODIFY (DEPTNO REFERENCES DEPARTMENT);
ALTER TABLE STUDENT ADD FOREIGN KEY(PROFNO) REFERENCES PROFESSOR;

SELECT DISTINCT PROFNO FROM STUDENT;

SELECT STUDNO, NAME, ROWID, ROWNUM FROM STUDENT;

-- DEPARTMENT 테이블 DNAME에 고유 인덱스 생성
CREATE UNIQUE INDEX IDX_DEPT_NAME ON DEPARTMENT(DNAME);

DROP INDEX IDX_DEPT_NAME;

SELECT /*+ INDEX(D IDX_DEPT_NAME) */ * FROM DEPARTMENT D;

-- STUDENT BIRTHDATE에 비고유 인덱스 생성
CREATE INDEX IDX_STUD_BIRTHDATE ON STUDENT(BIRTHDATE);

-- STUDENT테이블의 DEPTNO, GRADE에 결합인덱스 생성
--SELECT DISTINCT GRADE, DEPTNO FROM STUDENT; 
CREATE INDEX IDX_STUD_DEPTNO_GRADE ON STUDENT(DEPTNO, GRADE DESC);

SELECT * FROM STUDENT;

CREATE OR REPLACE VIEW VIEW_STUD AS 
SELECT STUDNO, NAME, USERID, DEPTNO FROM STUDENT;


SELECT DEPTNO, COUNT(*)
FROM VIEW_STUD
WHERE DEPTNO <> 201
GROUP BY DEPTNO;

INSERT INTO VIEW_STUD VALUES(12345, '홍길동', NULL);

SELECT * FROM VIEW_STUD;
SELECT * FROM (SELECT STUDNO, NAME, DEPTNO FROM STUDENT);
SELECT * FROM STUDENT;

CREATE FORCE VIEW VIEW_STUD2 AS 
SELECT * FROM STUDEN;

-- 학번, 이름, 학과번호, 학과이름으로 VIEW_STUD_DEPT라는 뷰를 생성
CREATE VIEW VIEW_STUD_DEPT AS 
SELECT STUDNO, NAME, DEPTNO, DNAME 
FROM STUDENT S NATURAL JOIN DEPARTMENT d ;

SELECT * FROM VIEW_STUD_DEPT;

-- 11111, 고길동, 101, 컴퓨터공학과
--INSERT INTO VIEW_STUD_DEPT VALUES(11111, '고길동', 101, '컴퓨터공학과');

-- 학과별 인원수를 조회하여 VIEW_STUD_DEPT2 라는 이름의 VIEW 생성
CREATE VIEW VIEW_STUD_DEPT2(DNO, CNT) AS 
SELECT DEPTNO, COUNT(*)
FROM STUDENT
GROUP BY DEPTNO
ORDER BY 1;

SELECT * FROM VIEW_STUD_DEPT2;

SELECT * FROM BOARD;

DROP SEQUENCE SEQ_BOARD;
CREATE SEQUENCE SEQ_BOARD;
SELECT * FROM BOARD;

INSERT INTO BOARD (NO, TITLE, CONTENT, WRITER) 
	VALUES (SEQ_BOARD.NEXTVAL, '제목' || SEQ_BOARD.CURRVAL, '내용', '작성자');
	
INSERT INTO BOARD (NO, TITLE, CONTENT, WRITER)
	SELECT SEQ_BOARD.NEXTVAL, TITLE, CONTENT, WRITER FROM BOARD;
	
-- 한페이지에 몇개씩?
SELECT * FROM (
	SELECT ROWNUM RN, A.*
	FROM (
		SELECT B.* FROM BOARD B 
		--WHERE ROWNUM <= 10
		ORDER BY 1 DESC
	) A
)
WHERE ROWNUM <= 10 AND RN > (4 - 1) * 30;

SELECT * FROM (
	SELECT /*+ INDEX_DESC(B SYS_C007007) */ B.*, ROWNUM RN 
	FROM BOARD B
	WHERE NO > 0
);

WITH A AS (
	SELECT /*+ INDEX_DESC(B SYS_C007007) */ B.*, ROWNUM RN 
	FROM BOARD B
	WHERE NO > 0
)
SELECT * 
FROM A
WHERE ROWNUM <= 10
AND RN > 10;

-- FILE SYSTEM
-- FILE의 권한

SELECT s.* FROM STUDENT s ;
SELECT D.* FROM STUDENT D ;

SELECT * FROM HR.EMPLOYEES;
SELECT * FROM EMP;

CREATE SYNONYM EMP FOR HR.EMPLOYEES;

CREATE PUBLIC SYNONYM STU FOR SAMPLE.STUDENT;

SELECT * FROM STU;

-- 사전
-- 접두어 : USER_ ALL_ DBA_

SELECT * FROM ALL_TABLES WHERE OWNER = 'SAMPLE';

SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'BOARD' ;

SELECT * FROM USER_CONSTRAINTS;

SELECT * FROM USER_INDEXES;